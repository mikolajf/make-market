# Publisher thread
import time
from collections.abc import Callable
from threading import Thread
from typing import Final

import zmq
import zmq.asyncio
from make_market.log.core import get_logger

PUBLISHER_THROTTHLE: Final[float] = 0.5

FRONTEND_ADDR = "inproc://frontend"
BACKEND_ADDR = "inproc://backend"


logger = get_logger(__name__)


def publish_messages(data_generator: Callable[[], bytes]) -> None:
    """
    Publishes messages generated by the provided data generator function to a ZeroMQ PUB socket.

    Args:
        data_generator (Callable[[], bytes]): A callable that returns a bytes object representing the data to be published.

    Raises:
        zmq.ZMQError: If an error occurs with the ZeroMQ socket, other than an interruption (zmq.ETERM).

    Notes:
        The function runs indefinitely, publishing messages at intervals of 0.1 seconds until interrupted.

    """
    ctx = zmq.Context.instance()
    publisher = ctx.socket(zmq.PUB)
    publisher.bind(FRONTEND_ADDR)

    while True:
        try:
            data = next(data_generator())
            publisher.send(data)
        except zmq.ZMQError as e:
            if e.errno == zmq.ETERM:
                break  # Interrupted
            raise
        time.sleep(PUBLISHER_THROTTHLE)  # Wait for 1/10th second


# Subscriber thread
def subscriber_thread(message_handler: Callable[[bytes], None]) -> None:
    """
    Starts a ZeroMQ subscriber thread that listens for messages and processes them using the provided message handler.

    Args:
        message_handler (Callable[[bytes], None]): A callback function that processes received messages.

    Raises:
        zmq.ZMQError: If there is an error with the ZeroMQ socket.

    """
    ctx = zmq.Context.instance()
    subscriber = ctx.socket(zmq.SUB)
    subscriber.connect(BACKEND_ADDR)
    subscriber.setsockopt_string(zmq.SUBSCRIBE, "")

    while True:
        try:
            message = subscriber.recv()
            message_handler(message)
        except zmq.ZMQError as e:
            if e.errno == zmq.ETERM:
                break  # Interrupted


class PubSubWithZeroMQ:
    """
    A class to handle publish-subscribe messaging using ZeroMQ.
    """

    def __init__(self) -> None:
        self.ctx = zmq.Context.instance()

    def start_publishers(self, publishers: list[Callable[[], bytes]]) -> None:
        """
        Starts multiple publisher threads.

        Args:
            publishers (list[Callable[[], bytes]]): A list of callables that return bytes.
                                                    Each callable represents a publisher function.

        """
        for pub in publishers:
            p_thread = Thread(target=publish_messages, args=(pub,))
            p_thread.start()

    def start_subscribers(self, subscribers: list[Callable[[bytes], None]]) -> None:
        """
        Starts a list of subscriber threads.

        Args:
            subscribers (list[Callable[[bytes], None]]): A list of subscriber functions.
                Each function should take a single argument of type bytes.

        """
        for sub in subscribers:
            s_thread = Thread(target=subscriber_thread, args=(sub,))
            s_thread.start()

    # async def async_client(self):
    #     ctx = zmq.Context.instance()
    #     subscriber = ctx.socket(zmq.SUB)
    #     subscriber.connect(BACKEND_ADDR)
    #     subscriber.setsockopt_string(zmq.SUBSCRIBE, "")

    #     while True:
    #         msg = await subscriber.recv()
    #         logger.info(f"Async client received: {msg}")

    # def start_async_client(self):
    #     loop = asyncio.get_event_loop()

    #     loop.run_until_complete(self.async_client())
    #     # loop.run_until_complete(do_other_things())

    #     loop.close()

    def setup_proxy(self) -> None:
        """
        Sets up a ZeroMQ proxy for message forwarding between a subscriber and a publisher.

        This method creates a subscriber socket that connects to the frontend address and a publisher
        socket that binds to the backend address. It then starts the ZeroMQ proxy to forward messages
        between these sockets. If interrupted by a KeyboardInterrupt, it will print "Interrupted" and
        clean up the sockets and terminate the ZeroMQ context.

        Returns:
            None

        """
        subscriber = self.ctx.socket(zmq.XSUB)
        subscriber.connect(FRONTEND_ADDR)

        publisher = self.ctx.socket(zmq.XPUB)
        publisher.bind(BACKEND_ADDR)

        try:
            zmq.proxy(subscriber, publisher)
        except KeyboardInterrupt:
            logger.info("Interrupted")

        del subscriber, publisher
        self.ctx.term()

    def start_proxy(self):
        proxy_thread = Thread(target=self.setup_proxy)
        proxy_thread.start()
